{
  "name": "node-test",
  "tagline": "A simple, asynchronous test runner for Node.js.",
  "body": "# node-test\r\n`node-test` is a simple, asynchronous test runner. It's designed to address what are limitations of existing Node.js test runners. Writing tests should be just like writing any other code.\r\n\r\n## Table of Contents\r\n\r\n* [Core Philosophy](#core-philosophy)\r\n* [Comparison With Other Test Runners](#comparison-with-other-test-runners)\r\n* [Install](#install)\r\n* [Example](#example)\r\n* [API](#api)\r\n    * [Suite](#suite)\r\n        * [Concurrent Tests](#concurrent-tests)\r\n        * [Serial Tests](#serial-tests)\r\n    * [Hooks](#hooks)\r\n    * [Assertions](#t-built-in-assertion-library)\r\n* [Running Multiple Suites](#running-multiple-suites)\r\n* [Todo](#todo)\r\n\r\n## Core Philosophy\r\n\r\n* Fast - Concurrent Tests\r\n* No global variables\r\n* Optional CLI  - Running a test file directly (`node test/test-something.js`) produces the same output as using the CLI.\r\n* Minimal - Just runs your tests and gives you the results. There's no fancy error interpretation, just a plain old Node.js error callstack.\r\n* No planning tests or counting assertions.\r\n* Asynchronous Tests - Prefers Promises, but supports Callbacks\r\n* Built-In assertion library build on the core `assert` module\r\n\r\n## Comparison With Other Test Runners\r\n\r\nThese test runners have many great features and heavily inspired this module. However, there are key differences.\r\n\r\n#### [Mocha](https://mochajs.org/), [Jasmine](http://jasmine.github.io/)\r\n1. Tests are run serially (one at a time).\r\n2. Defaults to using global variables (`describe()`, `it()`, etc).\r\n3. Mocha CLI is required, directly running a mocha test files fails.\r\n\r\n#### [tape](https://github.com/substack/tape)\r\n1. Tests are run serially (one at a time).\r\n2. The number of assertions has to be manually counted and planned (`t.plan()`) for every test.\r\n\r\n#### [ava](https://github.com/avajs/ava)\r\n1. Ava CLI is required, so directly running a test files fails.\r\n2. Ava's stack trace interpreter often removes helpful information, accesses properties on your object (causing side effects), and can interfere with other libraries built in error reporting (ie. Long Stack Traces)\r\n\r\n## Install\r\n\r\n```sh\r\n$ npm install --save-dev node-test\r\n```\r\n\r\n## Example\r\n\r\n```javascript\r\n'use strict';\r\nconst Suite = require('node-test');\r\n\r\nconst suite = new Suite('My Suite Name');\r\nsuite.test('Test 1', t => {\r\n    return funcReturnsPromise()\r\n        .then(result => {\r\n            t.equal(result, 2);\r\n        });\r\n});\r\n\r\nsuite.skip('Test 2', t => {\r\n    throw new Error('skipped');\r\n});\r\n\r\nsuite.todo('Test 3 - Coming Soon');\r\n\r\nsuite.test('Test 4', (t, state, done) => {\r\n    funcWithCallback(done);\r\n});\r\n\r\nsuite.failing('Test 5 - Need to fix this', t => {\r\n    t.equal(1+1, 3);\r\n});\r\n\r\n```\r\n\r\nOutput:\r\n```shell\r\n----My Suite Name----\r\npass 1 - Test 1\r\nskip 2 - Test 2\r\ntodo 3 - Test 3 - Coming Soon\r\npass 4 - Test 4\r\nfail 5 - Test 5 - Need to fix this #failing test\r\n\r\nTotal: 3\r\nFailed: 1 (5)\r\nPassed: 2 67%\r\n\r\n\r\nProcess finished with exit code 0\r\n```\r\n\r\n## API\r\n\r\n### Suite\r\nThe first thing you do with `node-test` is create a suite for your tests.\r\n##### `new Suite(name, [options])`- suite constructor\r\n###### Arguments\r\n- `name`: string - title for test\r\n- `options`: object \r\n  - `failFast`: boolean (default: false) - if a single test fails, stop all remaining tests in the suite\r\n\r\n```javascript\r\nconst Suite = require('node-test');\r\n\r\nconst suite = new Suite('My Suite Name');\r\n```\r\n\r\n#### Concurrent Tests\r\nBy default `node-test` runs tests concurrently. Concurrency means that the tests must be atomic. They should not depend on other tests for state.\r\n\r\nThe following methods are used to create concurrent tests.\r\n##### `suite.test(name, action)` - Create a new test.\r\n###### Arguments\r\n- `name`: string - title for test\r\n- `action`: function(t, state, done) - test implementation\r\n  - `t`: object (built-in assertions)\r\n  - (optional) `state`: object - result of `beforeEach` hook\r\n  - (optional) `done`: function - callback for asynchronous tests\r\n\r\n###### Test Resolution\r\n- Any `Error` throw synchronously will cause the test to fail.\r\n- Asynchronous test can return a Promise or use the `done()` callback.\r\n  - If the test returns a Promise, the test will pass or fail if the promise resolves or rejects, respectively.\r\n  - If the `done()` callback is used, the test will fail if the first argument is defined. See [Node.js style callbacks](https://nodejs.org/api/errors.html#errors_node_js_style_callbacks).\r\n\r\n###### Synchronous Test:\r\n```javascript\r\nsuite.test('My Test', t => {\r\n    const result = funcReturnsNumber();\r\n    t.equal(result, 2);\r\n});\r\n```\r\n###### Asynchronous Test with Promises:\r\n```javascript\r\nsuite.test('My Test', t => {\r\n    return funcReturnsPromise()\r\n        .then(result => {\r\n            t.equal(result, 2);\r\n        });\r\n});\r\n```\r\n###### Asynchronous Tests with a Callback\r\n```javascript\r\nsuite.test('My Test', (t, state, done) => {\r\n    funcWithCallback((err, result) => {\r\n        t.noError(err);\r\n        t.equal(result, 2);\r\n    });\r\n});\r\n\r\nsuite.test('My Test 2', (t, state, done) => {\r\n    funcWithCallbackNoValue(done);\r\n});\r\n```\r\n\r\n##### `suite.skip(name, action)` - Creates a new test that will be skipped when the suite is run.\r\n###### Arguments\r\nSame as `suite.test()`.\r\n\r\n##### `suite.only(name, action)` - Creates a new test that will be run exclusively.\r\nWhen the suite run, `only` tests will be run and all other tests will be skipped.\r\n###### Arguments\r\nSame as `suite.test()`.\r\n\r\n##### `suite.todo(name)` - Creates a test placeholder.\r\nThe \"test\" will be shown in the output, but will not count toward the total.\r\n###### Arguments\r\n- `name`: string - title for test\r\n\r\n##### `suite.failing(name, action)` - Creates a new test that is expected to fail.\r\nThe test included as a failed test in the output, but don't cause the exit code to change (indicating the build failed).\r\n###### Arguments\r\nSame as `suite.test()`.\r\n\r\n#### Serial Tests\r\n`node-test` also supports serial tests (one at a time). Most of the time concurrent test are preferable, however there are times (such as when accessing a database) that you may want tests to run serially.\r\n\r\nWithin a suite, serial tests are executed first followed by any concurrent tests. However, multiple suites are run concurrently. So two serial tests could run at the same time if they are members of different suites.\r\n\r\nThe following methods are used to create serial tests. There usage is identical to the equivalent concurrent method.\r\n##### `suite.serial.test(name, action)`\r\n###### Arguments\r\nSame as `suite.test()`.\r\n\r\n##### `suite.serial.skip(name, action)`\r\n###### Arguments\r\nSame as `suite.test()`.\r\n\r\n##### `suite.serial.only(name, action)`\r\n###### Arguments\r\nSame as `suite.test()`.\r\n\r\n##### `suite.serial.todo(name)`\r\n###### Arguments\r\nSame as `suite.test()`.\r\n\r\n##### `suite.serial.failing(name, action)`\r\n###### Arguments\r\nSame as `suite.test()`.\r\n\r\n### Hooks\r\n`node-test` provides four hooks. The hooks are run serially to the tests.\r\n\r\n#### `suite.before(action)` - Run before all tests in the suite.\r\n###### Arguments\r\n- `name`: string - title for test\r\n- `action`: function(t, state, done) - test implementation\r\n  - `t`: object (built-in assertions)\r\n  - (optional) `done`: function - callback for asynchronous tests\r\n\r\n#### `suite.after(action)` - Run after all tests in the suite.\r\n###### Arguments\r\nSame as `suite.before()`.\r\n\r\n#### `suite.beforeEach(action)` - Run before each individual tests in the suite.\r\n###### Arguments\r\nSame as `suite.before()`.\r\n\r\nThe `beforeEach` hook runs before each test in the suite.\r\n###### Usage with `suite.beforeEach()`\r\n```javascript\r\nsuite.beforeEach(t => {\r\n    return {\r\n        data: 2\r\n    };\r\n});\r\n\r\nsuite.test('My Test 1', (t, state) => {\r\n    t.equal(1+1, state.data);\r\n    state.date = 3;\r\n});\r\n\r\nsuite.test('My Test 2', (t, state) => {\r\n    t.equal(2, state.data); //state is still 2, because beforeEach is run individual for each test\r\n});\r\n```\r\n#### `suite.afterEach(action)` - Run after each individual tests in the suite.\r\n###### Arguments\r\nSame as `suite.before()`.\r\n\r\n#### Other Members\r\n\r\n##### `suite.setTimeout(delay)` - Set the time limit for tests (default: 5000)\r\nTests whose execution time exceeds the delay will fail.\r\n###### Arguments\r\n- `delay`: number - timeout in milliseconds\r\n\r\n### t (Built-In Assertion Library)\r\n`node-test` includes an assertion library that is a bit more feature rich than the core assert module.\r\n * For every method, `message` is optional. If defined, it will be displayed if the assertion fails.*\r\n \r\n#### `t.pass()`\r\n```javascript\r\nt.pass();\r\n```\r\n#### `t.fail([message])`\r\n```javascript\r\nt.fail();\r\n```\r\n#### `t.true(value, [message])`\r\nAn assertion that `value` is strictly true.\r\n```javascript\r\nconst value = true;\r\nt.true(value);\r\n\r\nconst arr = ['a'];\r\nt.true(arr.length === 1);\r\n```\r\n#### `t.false(value, [message])`\r\nAn assertion that `value` is strictly false.\r\n```javascript\r\nconst value = false;\r\nt.false(value);\r\n```\r\n#### `t.truthy(value, [message])` alias: `t.assert()`\r\nAn assertion that `value` is strictly truthy.\r\n```javascript\r\nconst value = 1;\r\nt.truthy(value);\r\n```\r\n#### `t.falsey(value, [message])`\r\nAn assertion that `value` is strictly falsey.\r\n```javascript\r\nconst value = 0;\r\nt.falsey(value);\r\n```\r\n#### `t.equal(value, expected, [message])` aliases: `t.is(), t.equals()`\r\nAn assertion that `value` is strictly equal to `expected`.\r\n```javascript\r\nconst value = 1;\r\nt.equal(value, 1);\r\n```\r\n#### `t.notEqual(value, expected, [message])` aliases: `t.not(), t.notEquals()`\r\nAn assertion that `value` is strictly not equal to `expected`.\r\n```javascript\r\nconst value = 1;\r\nt.notEqual(value, 2);\r\n```\r\n#### `t.deepEqual(value, expected, [message])`\r\nAn assertion that `value` is strictly and deeply equal to `expected`. Deep equality is tested by the [not-so-shallow](https://github.com/sotojuan/not-so-shallow) module.\r\n```javascript\r\nconst value = { data: 1234 };\r\nt.deepEqual(value, { data: 1234 });\r\n```\r\n#### `t.notDeepEqual(value, expected, [message])`\r\nAn assertion that `value` is strictly and deeply not equal to `expected`.\r\n```javascript\r\nconst value = { data: 1234 };\r\nt.notDeepEqual(value, { data: 5678 });\r\n```\r\n#### `t.greaterThan(value, expected, [message])`\r\nAn assertion that `value` is greater than `expected`.\r\n```javascript\r\nconst value = 2;\r\nt.greaterThan(value, 1);\r\n```\r\n#### `t.greaterThanOrEqual(value, expected, [message])`\r\nAn assertion that `value` is greater than or equal to `expected`.\r\n```javascript\r\nconst value = 2;\r\nt.greaterThanOrEqual(value, 2);\r\n```\r\n#### `t.lessThan(value, expected, [message])`\r\nAn assertion that `value` is less than `expected`.\r\n```javascript\r\nconst value = 1;\r\nt.lessThan(value, 2);\r\n```\r\n#### `t.lessThanOrEqual(value, expected, [message])`\r\nAn assertion that `value` is less than or equal to `expected`. *`message` is optional. If defined, it will be displayed if the assertion fails.\r\n```javascript\r\nconst value = 1;\r\nt.lessThanOrEqual(value, 1);\r\n```\r\n#### `t.noError(error, [message])`\r\nAn assertion that `error` is falsey. This is functionally similar to `t.falsey()`, but the assertion error message indicates the failure was due to an `Error`.\r\n```javascript\r\nfuncWithCallback((err, result) => {\r\n    t.noError(err);\r\n});\r\n```\r\n#### `t.notThrows(fn, [message])`\r\nAn assertion that `fn` is function that does not throws an Error synchronously nor asynchronously (via Promise or callback).\r\n###### Arguments\r\n- `fn`: function([done]) - code to assert throws\r\n  - (optional) `done`: function - callback for asynchronous test\r\n\r\n###### Synchronous Assertion\r\nWould Pass:\r\n```javascript\r\nt.notThrows(() => {\r\n    t.equal(1, 1);\r\n});\r\n```\r\nWould Fail:\r\n```javascript\r\nt.throws(() => {\r\n    throw new Error('error');\r\n});\r\n```\r\n###### Asynchronous Assertion with Promises\r\n```javascript\r\nt.notThrows(() => {\r\n    return funcReturnsPromise();\r\n});\r\n```\r\n###### Asynchronous/Synchronous Assertion with Callback\r\nThe callback can be asynchronous or synchronous. The callback can be executed immediately or later. It will be handled the same.\r\n```javascript\r\nt.notThrows(done1 => {\r\n    funcWithAsyncCallback(done1);\r\n});\r\nt.notThrows(done1 => {\r\n    funcWithSyncCallback(done1);\r\n});\r\nt.notThrows(done1 => {\r\n    funcWithCallback((err, result) => {\r\n        t.noError(err);\r\n        t.equal(result, 2);\r\n        done1();\r\n    });\r\n});\r\n```\r\nEven if an asynchronous mode is used, synchronous errors are caught.\r\n###### Mixed Synchronous & Asynchronous\r\nWould Fail:\r\n```javascript\r\nt.notThrows(done => {\r\n    funcWithAsyncCallback(done);\r\n    throw new Error('message');\r\n});\r\nt.notThrows(done => {\r\n    throw new Error('message');\r\n    return funcReturnsPromise();\r\n});\r\n```\r\n\r\n#### `t.throws(fn, [errTestFn], [message])`\r\nAn assertion that `fn` is function that either throws an Error synchronously or asynchronously (via Promise or callback).\r\n###### Arguments\r\n- `fn`: function([done]) - code to assert throws\r\n  - (optional) `done`: function - callback for asynchronous test\r\n- `errTestFn`: function() - code to test the error\r\n\r\nExcept for the `errTestFn` argument, this functions as the opposite of `t.notThrow()`. That is `throws` passes when there is an Error rather passing when there is no Error. For more usage details, look at the `notThrows` examples.\r\n\r\nPassing `errTestFn` allows testing that the Error received is the Error expected.\r\n```javascript\r\nt.throws(() => {\r\n    return funcReturnsPromise();\r\n},\r\nerr => {\r\n    t.true(err instanceof TypeError);\r\n    t.equal(err.message, 'invalid argument');\r\n});\r\n```\r\n\r\n#### `t.count(fn, count, [message])`\r\nAn asynchronous assertion that `fn` eventually executes a callback a precise number of times.\r\n\r\n```javascript\r\nt.count(done1 => {\r\n    funcWithCallback(done1);\r\n    funcWithCallback(done1);\r\n    funcWithCallback(done1);\r\n}, 3);\r\n```\r\n\r\n## Running Multiple Suites\r\nThere are couple ways to run multiple suites.\r\n1. The easiest (and least flexible) way to just place multiple suites in a single file.\r\n2. A more flexible way is to create one suite per file and create an index file to run them all.\r\n\r\n    Imagine your `test` directory looks like this:\r\n    ```\r\n    suite1.js\r\n    suite2.js\r\n    suite3.js\r\n    ```\r\n    \r\n    You could create a file called `index.js` with these contents:\r\n    ```javascript\r\n    'use strict';\r\n    require('./suite1');\r\n    require('./suite2');\r\n    require('./suite3');\r\n    ```\r\n    \r\n    Then add the script to your `package.json` file:\r\n    ```json\r\n    \"scripts\": {\r\n      \"test\": \"node test/index.js\"\r\n    }\r\n    ```\r\n    \r\n    Now you can run individual suites or the whole thing from the command line.\r\n    ```shell\r\n    node tests/suite1.js\r\n    npm test\r\n    ```\r\n3. The up coming CLI will make it easier to execute multiple suites without needing to maintain an `index.js`.\r\n\r\n## Todo\r\n\r\n* CLI \r\n    * file watcher\r\n    * only run certain files (glob matching)\r\n    * run suites in individual contexts\r\n    * harmony flag\r\n* js-report support\r\n* test Error output\r\n\r\n## Considering\r\n* code coverage\r\n* slow tests\r\n* logging - ala Karma\r\n* support CoffeeScript, TypeScript\r\n* support plugins\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}